<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Kelp Forest</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #001122, #003366);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        input[type="range"] {
            width: 150px;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 12px;
            line-height: 1.4;
        }

        #loadingStatus {
            color: #88ccff;
            font-weight: bold;
        }

        .control-group span {
            color: #88ccff;
            font-weight: bold;
        }

        #kelpCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="kelpCanvas"></canvas>
        
        <div id="controls">
            <div class="control-group">
                <label>Animation Speed: <span id="speedValue">1.0</span></label>
                <input type="range" id="animationSpeed" min="0.1" max="3" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <label>Wave Intensity: <span id="intensityValue">1.0</span></label>
                <input type="range" id="waveIntensity" min="0.1" max="3" step="0.1" value="1.0">
            </div>
            <div class="control-group">
                <label>Current Direction: <span id="directionValue">0</span>°</label>
                <input type="range" id="currentDirection" min="0" max="360" step="10" value="0">
            </div>
            <div class="control-group">
                <label>Camera Distance: <span id="distanceValue">15</span></label>
                <input type="range" id="cameraDistance" min="5" max="50" step="1" value="15">
            </div>
        </div>
        
        <div id="info">
            Mouse: Click and drag to orbit | Scroll: Zoom<br>
            Kelp Forest (Canvas-based with GLB fallback)<br>
            <span id="loadingStatus">Initializing...</span>
        </div>
    </div>

    <script type="module">
        // Import Three.js using ES6 modules from reliable CDN
        import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.150.0/examples/jsm/loaders/GLTFLoader.js';
        
        console.log('🌊 Starting Kelp Forest Viewer...');
        
        // Global variables
        let scene, camera, renderer, mixer, clock;
        let kelpModel = null;
        let kelpMeshes = [];
        let originalPositions = new Map();
        
        // Animation controls
        let animationSpeed = 1.0;
        let waveIntensity = 1.0;
        let currentDirection = 0;
        let cameraDistance = 15;
        
        // Camera controls
        let targetRotationX = 0, targetRotationY = 0;
        let rotationX = 0, rotationY = 0;
        let isMouseDown = false;
        
        function updateLoadingStatus(message) {
            const statusElement = document.getElementById('loadingStatus');
            if (statusElement) {
                statusElement.textContent = message;
            }
            console.log('📢', message);
        }
        
        function initThreeJS() {
            updateLoadingStatus('Initializing 3D scene...');
            
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('kelpCanvas'),
                antialias: true,
                alpha: true
            });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            clock = new THREE.Clock();
            
            // Create underwater gradient background
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            
            const gradient = context.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.3, '#4682B4');
            gradient.addColorStop(0.7, '#2F4F4F');
            gradient.addColorStop(1, '#191970');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 512, 512);
            
            scene.background = new THREE.CanvasTexture(canvas);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x87CEEB, 0.4);
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0xB0E0E6, 1.2);
            sunLight.position.set(20, 50, 10);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);
            
            const causticLight = new THREE.SpotLight(0x00CED1, 0.6, 30, Math.PI / 6, 0.3);
            causticLight.position.set(10, 15, 5);
            scene.add(causticLight);
            
            // Seafloor
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            const floorMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDEB887,
                transparent: true,
                opacity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -5;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Position camera
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);
            
            updateLoadingStatus('3D scene ready. Attempting to load GLB...');
            console.log('✅ Three.js scene initialized');
        }
        
        async function loadGLB() {
            try {
                updateLoadingStatus('Loading animated_kelp.glb...');
                
                // First check if the file exists
                const response = await fetch('./animated_kelp.glb');
                if (!response.ok) {
                    throw new Error(`GLB file not found: ${response.status} ${response.statusText}`);
                }
                
                updateLoadingStatus('GLB file found, parsing...');
                
                const loader = new GLTFLoader();
                
                return new Promise((resolve, reject) => {
                    loader.load(
                        './animated_kelp.glb',
                        
                        // Success
                        function(gltf) {
                            console.log('🎉 GLB loaded successfully!', gltf);
                            
                            kelpModel = gltf.scene;
                            
                            // Setup animations
                            if (gltf.animations && gltf.animations.length > 0) {
                                mixer = new THREE.AnimationMixer(kelpModel);
                                gltf.animations.forEach(clip => {
                                    const action = mixer.clipAction(clip);
                                    action.play();
                                });
                                console.log(`✨ Started ${gltf.animations.length} animations`);
                            }
                            
                            // Process meshes
                            let meshCount = 0;
                            kelpModel.traverse(function(child) {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    meshCount++;
                                    kelpMeshes.push(child);
                                    
                                    // Store original positions for wave effects
                                    if (child.geometry && child.geometry.attributes.position) {
                                        const positions = child.geometry.attributes.position.array.slice();
                                        originalPositions.set(child, {
                                            positions: positions,
                                            offset1: Math.random() * Math.PI * 2,
                                            offset2: Math.random() * Math.PI * 2,
                                            freq1: 0.5 + Math.random() * 0.8,
                                            freq2: 0.3 + Math.random() * 0.6,
                                            amplitude1: 0.8 + Math.random() * 0.6,
                                            amplitude2: 0.6 + Math.random() * 0.5
                                        });
                                    }
                                }
                            });
                            
                            console.log(`📈 Processed ${meshCount} meshes`);
                            
                            // Auto-scale and center
                            const box = new THREE.Box3().setFromObject(kelpModel);
                            const size = box.getSize(new THREE.Vector3());
                            const center = box.getCenter(new THREE.Vector3());
                            
                            const maxDim = Math.max(size.x, size.y, size.z);
                            if (maxDim > 20 || maxDim < 1) {
                                const scale = maxDim > 20 ? 20 / maxDim : 2 / maxDim;
                                kelpModel.scale.setScalar(scale);
                            }
                            
                            kelpModel.position.set(-center.x, -center.y, -center.z);
                            scene.add(kelpModel);
                            
                            // Position camera
                            const distance = Math.max(maxDim * 1.5, 10);
                            camera.position.set(0, size.y * 0.3, distance);
                            camera.lookAt(0, 0, 0);
                            
                            updateLoadingStatus('GLB loaded successfully!');
                            resolve(gltf);
                        },
                        
                        // Progress
                        function(xhr) {
                            if (xhr.lengthComputable) {
                                const percent = (xhr.loaded / xhr.total * 100).toFixed(1);
                                updateLoadingStatus(`Loading GLB: ${percent}%`);
                            }
                        },
                        
                        // Error
                        function(error) {
                            console.error('❌ GLB loading failed:', error);
                            reject(error);
                        }
                    );
                });
                
            } catch (error) {
                console.error('❌ GLB loading error:', error);
                throw error;
            }
        }
        
        function createFallbackKelp() {
            console.log('🔄 Creating fallback kelp forest...');
            updateLoadingStatus('Creating fallback kelp forest...');
            
            // Create multiple kelp strands
            for (let i = 0; i < 12; i++) {
                const height = 4 + Math.random() * 8;
                const radius = 0.1 + Math.random() * 0.15;
                
                const geometry = new THREE.CylinderGeometry(
                    radius * 0.3, radius, height, 8, 15
                );
                
                const hue = 85 + Math.random() * 30; // Green variations
                const saturation = 60 + Math.random() * 20;
                const lightness = 25 + Math.random() * 15;
                
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(hue/360, saturation/100, lightness/100),
                    transparent: true,
                    opacity: 0.85
                });
                
                const kelpMesh = new THREE.Mesh(geometry, material);
                
                // Position in a rough circle
                const angle = (i / 12) * Math.PI * 2;
                const radius_pos = 3 + Math.random() * 4;
                kelpMesh.position.set(
                    Math.cos(angle) * radius_pos,
                    height / 2 - 2,
                    Math.sin(angle) * radius_pos
                );
                
                kelpMesh.castShadow = true;
                scene.add(kelpMesh);
                kelpMeshes.push(kelpMesh);
                
                // Store original positions for animation
                const positions = geometry.attributes.position.array.slice();
                originalPositions.set(kelpMesh, {
                    positions: positions,
                    offset1: Math.random() * Math.PI * 2,
                    offset2: Math.random() * Math.PI * 2,
                    freq1: 0.5 + Math.random() * 0.8,
                    freq2: 0.3 + Math.random() * 0.6,
                    amplitude1: 0.8 + Math.random() * 0.6,
                    amplitude2: 0.6 + Math.random() * 0.5
                });
            }
            
            console.log(`✅ Created ${kelpMeshes.length} fallback kelp strands`);
            updateLoadingStatus('Fallback kelp forest ready!');
        }
        
        function deformKelp(mesh, time) {
            const data = originalPositions.get(mesh);
            if (!data || !mesh.geometry.attributes.position) return;

            const positions = mesh.geometry.attributes.position;
            const originalPos = data.positions;
            
            const dirRad = (currentDirection * Math.PI) / 180;
            const wave1 = Math.sin(time * data.freq1 + data.offset1) * data.amplitude1;
            const wave2 = Math.cos(time * data.freq2 + data.offset2) * data.amplitude2;
            
            // Get height bounds
            let minY = Infinity, maxY = -Infinity;
            for (let i = 1; i < originalPos.length; i += 3) {
                minY = Math.min(minY, originalPos[i]);
                maxY = Math.max(maxY, originalPos[i]);
            }
            const height = maxY - minY;
            
            // Deform vertices
            for (let i = 0; i < positions.count; i++) {
                const i3 = i * 3;
                
                const originalX = originalPos[i3];
                const originalY = originalPos[i3 + 1];
                const originalZ = originalPos[i3 + 2];
                
                const heightFactor = height > 0 ? (originalY - minY) / height : 0;
                const heightFactorSquared = heightFactor * heightFactor;
                
                const bendAmountX = (wave1 + wave2 * 0.6) * waveIntensity * heightFactorSquared * 0.8;
                const bendAmountZ = (wave2 + wave1 * 0.4) * waveIntensity * heightFactorSquared * 0.8;
                
                const finalBendX = bendAmountX * Math.cos(dirRad) + bendAmountZ * Math.sin(dirRad) * 0.3;
                const finalBendZ = bendAmountZ * Math.sin(dirRad) + bendAmountX * Math.cos(dirRad) * 0.3;
                
                positions.setX(i, originalX + finalBendX);
                positions.setY(i, originalY);
                positions.setZ(i, originalZ + finalBendZ);
            }
            
            positions.needsUpdate = true;
            mesh.geometry.computeVertexNormals();
        }
        
        function setupControls() {
            // Animation Speed
            const speedSlider = document.getElementById('animationSpeed');
            speedSlider.addEventListener('input', function(e) {
                animationSpeed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = animationSpeed.toFixed(1);
            });

            // Wave Intensity
            const intensitySlider = document.getElementById('waveIntensity');
            intensitySlider.addEventListener('input', function(e) {
                waveIntensity = parseFloat(e.target.value);
                document.getElementById('intensityValue').textContent = waveIntensity.toFixed(1);
            });

            // Current Direction
            const directionSlider = document.getElementById('currentDirection');
            directionSlider.addEventListener('input', function(e) {
                currentDirection = parseFloat(e.target.value);
                document.getElementById('directionValue').textContent = currentDirection;
            });

            // Camera Distance
            const distanceSlider = document.getElementById('cameraDistance');
            distanceSlider.addEventListener('input', function(e) {
                cameraDistance = parseFloat(e.target.value);
                document.getElementById('distanceValue').textContent = cameraDistance;
            });
            
            // Mouse controls
            document.addEventListener('mousedown', () => isMouseDown = true);
            document.addEventListener('mouseup', () => isMouseDown = false);
            
            document.addEventListener('mousemove', function(event) {
                if (isMouseDown) {
                    targetRotationY += event.movementX * 0.01;
                    targetRotationX += event.movementY * 0.01;
                    targetRotationX = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetRotationX));
                }
            });

            document.addEventListener('wheel', function(event) {
                cameraDistance += event.deltaY * 0.01;
                cameraDistance = Math.max(2, Math.min(50, cameraDistance));
                distanceSlider.value = cameraDistance;
                document.getElementById('distanceValue').textContent = cameraDistance.toFixed(1);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime() * animationSpeed;
            
            // Update GLB animations
            if (mixer) {
                mixer.update(deltaTime * animationSpeed);
            }
            
            // Apply wave deformation
            kelpMeshes.forEach(mesh => {
                deformKelp(mesh, time);
            });
            
            // Camera movement
            rotationX += (targetRotationX - rotationX) * 0.05;
            rotationY += (targetRotationY - rotationY) * 0.05;
            
            camera.position.x = Math.sin(rotationY) * Math.cos(rotationX) * cameraDistance;
            camera.position.y = Math.sin(rotationX) * cameraDistance + 2;
            camera.position.z = Math.cos(rotationY) * Math.cos(rotationX) * cameraDistance;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Main initialization
        async function init() {
            try {
                initThreeJS();
                setupControls();
                
                // Try to load GLB, fallback to procedural kelp
                try {
                    await loadGLB();
                } catch (error) {
                    console.log('🔄 GLB failed, using fallback kelp');
                    updateLoadingStatus('GLB failed, using procedural kelp...');
                    createFallbackKelp();
                }
                
                animate();
                
            } catch (error) {
                console.error('💥 Initialization failed:', error);
                updateLoadingStatus('Error: Failed to initialize');
            }
        }
        
        // Start the application
        init();
    </script>
</body>
</html>
