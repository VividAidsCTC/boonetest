<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Optimized Kelp Forest</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: Arial, sans-serif;
    }
    canvas { display: block; }
    
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 40, 80, 0.9);
      padding: 15px;
      border-radius: 8px;
      color: white;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      min-width: 200px;
      z-index: 100;
    }
    
    .control-group {
      margin-bottom: 12px;
    }
    
    .control-group label {
      display: block;
      font-size: 12px;
      margin-bottom: 5px;
      color: #a8d0f0;
    }
    
    .control-group input[type="range"] {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
    }
    
    .control-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #00d4ff;
      border-radius: 50%;
      cursor: pointer;
    }
    
    .value {
      color: #00d4ff;
      font-weight: bold;
    }
    
    #info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.8);
      font-size: 11px;
      background: rgba(0, 40, 80, 0.7);
      padding: 8px 12px;
      border-radius: 6px;
      line-height: 1.3;
    }
    
    #fps {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div id="controls">
    <div class="control-group">
      <label>Animation Speed: <span class="value" id="speedVal">1.0</span></label>
      <input type="range" id="animSpeed" min="0" max="2" step="0.1" value="1.0">
    </div>
    
    <div class="control-group">
      <label>Wave Strength: <span class="value" id="waveVal">0.5</span></label>
      <input type="range" id="waveStrength" min="0" max="1" step="0.1" value="0.5">
    </div>
    
    <div class="control-group">
      <label>Kelp Count: <span class="value" id="countVal">8</span></label>
      <input type="range" id="kelpCount" min="3" max="15" step="1" value="8">
    </div>
    
    <div class="control-group">
      <label>Quality: <span class="value" id="qualityVal">Medium</span></label>
      <input type="range" id="quality" min="1" max="3" step="1" value="2">
    </div>
  </div>
  
  <div id="fps">FPS: --</div>
  
  <div id="info">
    <strong>Optimized Kelp Forest</strong><br>
    Drag to rotate • Scroll to zoom<br>
    <span id="statusText">Loading...</span>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    console.log('🚀 Starting Optimized Kelp Forest...');
    
    // Performance monitoring
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 0;
    
    // Scene setup with performance optimizations
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x2F4F4F, 20, 80); // Add fog for distant object culling
    
    // Simple gradient background (more performant than texture)
    scene.background = new THREE.Color(0x2F4F4F);
    
    // Camera
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 5, 12);
    
    // Renderer with performance settings
    const renderer = new THREE.WebGLRenderer({ 
      antialias: false, // Disable for better performance
      powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio
    renderer.shadowMap.enabled = false; // Disable shadows for performance
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);
    
    // Simplified camera controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.minDistance = 3;
    controls.maxDistance = 25;
    controls.target.set(0, 3, 0);
    
    // Minimal lighting for performance
    const ambientLight = new THREE.AmbientLight(0x87CEEB, 0.6);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xB0E0E6, 0.8);
    directionalLight.position.set(10, 20, 5);
    scene.add(directionalLight);
    
    // Simple, flat ground plane
    const groundGeometry = new THREE.PlaneGeometry(60, 60);
    const groundMaterial = new THREE.MeshLambertMaterial({ 
      color: 0x8B7355,
      transparent: true,
      opacity: 0.8
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
    ground.position.y = 0; // At sea level
    scene.add(ground);
    
    // Control variables
    let animSpeed = 1.0;
    let waveStrength = 0.5;
    let kelpCount = 8;
    let quality = 2; // 1=Low, 2=Medium, 3=High
    
    // Kelp forest data
    let kelpModels = [];
    let originalKelpModel = null;
    let kelpAnimationData = []; // Store animation data separately for performance
    
    // Performance optimization: Reuse geometry and materials
    let sharedGeometry = null;
    let sharedMaterials = [];
    
    function updateStatus(text) {
      document.getElementById('statusText').textContent = text;
    }
    
    function updateFPS() {
      frameCount++;
      const currentTime = performance.now();
      if (currentTime >= lastTime + 1000) {
        fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        document.getElementById('fps').textContent = `FPS: ${fps}`;
        frameCount = 0;
        lastTime = currentTime;
        
        // Auto-adjust quality based on FPS
        if (fps < 30 && quality > 1) {
          quality = Math.max(1, quality - 1);
          document.getElementById('quality').value = quality;
          updateQualityDisplay();
          console.log('🔧 Auto-reduced quality for better performance');
        }
      }
    }
    
    function updateQualityDisplay() {
      const qualityNames = ['Low', 'Medium', 'High'];
      document.getElementById('qualityVal').textContent = qualityNames[quality - 1];
      
      // Adjust renderer settings based on quality
      switch(quality) {
        case 1: // Low
          renderer.setPixelRatio(1);
          scene.fog.near = 15;
          scene.fog.far = 40;
          break;
        case 2: // Medium
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
          scene.fog.near = 20;
          scene.fog.far = 60;
          break;
        case 3: // High
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          scene.fog.near = 25;
          scene.fog.far = 80;
          break;
      }
    }
    
    // Setup controls
    function setupControls() {
      document.getElementById('animSpeed').addEventListener('input', function(e) {
        animSpeed = parseFloat(e.target.value);
        document.getElementById('speedVal').textContent = animSpeed.toFixed(1);
      });
      
      document.getElementById('waveStrength').addEventListener('input', function(e) {
        waveStrength = parseFloat(e.target.value);
        document.getElementById('waveVal').textContent = waveStrength.toFixed(1);
      });
      
      document.getElementById('kelpCount').addEventListener('input', function(e) {
        const newCount = parseInt(e.target.value);
        document.getElementById('countVal').textContent = newCount;
        if (newCount !== kelpCount) {
          kelpCount = newCount;
          if (originalKelpModel) {
            recreateKelpForest();
          }
        }
      });
      
      document.getElementById('quality').addEventListener('input', function(e) {
        quality = parseInt(e.target.value);
        updateQualityDisplay();
      });
    }
    
    // Optimized kelp creation using instancing
    function createOptimizedKelp(gltf) {
      console.log('🌿 Creating optimized kelp forest...');
      
      // Extract geometry and materials from the original model
      originalKelpModel.traverse(function(child) {
        if (child.isMesh && !sharedGeometry) {
          sharedGeometry = child.geometry.clone();
          if (Array.isArray(child.material)) {
            sharedMaterials = child.material.map(mat => mat.clone());
          } else {
            sharedMaterials = [child.material.clone()];
          }
          
          // Optimize materials
          sharedMaterials.forEach(material => {
            material.transparent = true;
            material.opacity = 0.9;
            // Remove expensive material features
            if (material.normalMap) material.normalMap = null;
            if (material.roughnessMap) material.roughnessMap = null;
          });
        }
      });
      
      recreateKelpForest();
    }
    
    function recreateKelpForest() {
      // Remove existing kelp
      kelpModels.forEach(kelp => scene.remove(kelp));
      kelpModels = [];
      kelpAnimationData = [];
      
      if (!sharedGeometry || !sharedMaterials.length) return;
      
      console.log(`🔄 Creating ${kelpCount} kelp instances...`);
      
      for (let i = 0; i < kelpCount; i++) {
        // Create mesh using shared geometry and materials
        const kelp = new THREE.Mesh(sharedGeometry, sharedMaterials[0]);
        
        // Position in circle
        const angle = (i / kelpCount) * Math.PI * 2;
        const radius = 3 + Math.random() * 6;
        kelp.position.set(
          Math.cos(angle) * radius,
          0,
          Math.sin(angle) * radius
        );
        
        // Random rotation and scale
        kelp.rotation.y = Math.random() * Math.PI * 2;
        const scale = 0.8 + Math.random() * 0.4;
        kelp.scale.setScalar(scale);
        
        scene.add(kelp);
        kelpModels.push(kelp);
        
        // Store animation data separately for performance
        kelpAnimationData.push({
          originalPosition: kelp.position.clone(),
          phase: Math.random() * Math.PI * 2,
          frequency: 0.5 + Math.random() * 0.5
        });
      }
      
      updateStatus(`Forest ready! ${kelpCount} kelp models`);
    }
    
    // Load GLB model
    const loader = new THREE.GLTFLoader();
    updateStatus('Loading kelp model...');
    
    loader.load(
      'https://raw.githubusercontent.com/VividAidsCTC/boonetest/99e8af7024a27e85ca31e3bedec37c7c8204101a/animated_kelp.glb',
      
      function(gltf) {
        console.log('✅ Kelp model loaded');
        originalKelpModel = gltf.scene;
        
        // Scale down the original model if it's too large
        const box = new THREE.Box3().setFromObject(originalKelpModel);
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        
        if (maxDim > 5) {
          const scale = 3 / maxDim;
          originalKelpModel.scale.setScalar(scale);
        }
        
        createOptimizedKelp(gltf);
      },
      
      function(progress) {
        const percent = progress.total ? (progress.loaded / progress.total * 100).toFixed(0) : '...';
        updateStatus(`Loading: ${percent}%`);
      },
      
      function(error) {
        console.error('❌ Error loading kelp:', error);
        updateStatus('Error loading model');
        createFallbackKelp();
      }
    );
    
    // Simple fallback kelp for if model fails to load
    function createFallbackKelp() {
      console.log('🔄 Creating fallback kelp...');
      
      for (let i = 0; i < kelpCount; i++) {
        const geometry = new THREE.CylinderGeometry(0.1, 0.2, 3, 6, 1);
        const material = new THREE.MeshLambertMaterial({ color: 0x228B22 });
        const kelp = new THREE.Mesh(geometry, material);
        
        const angle = (i / kelpCount) * Math.PI * 2;
        const radius = 3 + Math.random() * 6;
        kelp.position.set(
          Math.cos(angle) * radius,
          1.5,
          Math.sin(angle) * radius
        );
        
        scene.add(kelp);
        kelpModels.push(kelp);
        
        kelpAnimationData.push({
          originalPosition: kelp.position.clone(),
          phase: Math.random() * Math.PI * 2,
          frequency: 0.5 + Math.random() * 0.5
        });
      }
      
      updateStatus('Fallback kelp ready!');
    }
    
    // Optimized animation loop
    const clock = new THREE.Clock();
    let time = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      
      const deltaTime = clock.getDelta();
      time += deltaTime * animSpeed;
      
      // Update controls
      controls.update();
      
      // Animate kelp with minimal calculations
      for (let i = 0; i < kelpModels.length; i++) {
        const kelp = kelpModels[i];
        const data = kelpAnimationData[i];
        
        if (waveStrength > 0) {
          const wave = Math.sin(time * data.frequency + data.phase) * waveStrength;
          kelp.position.x = data.originalPosition.x + wave * 0.5;
          kelp.rotation.z = wave * 0.2;
        }
      }
      
      // Update performance counter
      updateFPS();
      
      renderer.render(scene, camera);
    }
    
    // Handle window resize
    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Initialize
    setupControls();
    updateQualityDisplay();
    animate();
    
    console.log('🎬 Optimized kelp forest ready');
  </script>
</body>
</html>
